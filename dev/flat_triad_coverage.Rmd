---
title: "flat_triad_coverage.Rmd empty"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)
```

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```

# triad_coverage

```{r development-triad_coverage}
# Prepare the code of your function here
```

```{r function-triad_coverage}
#' Triad Coverage
#'
#' @param triads a tibble triad
#' @param weighted a boolean specifying if songs should be weighted using tvc's bias correction method
#'
#' @return \code{triad_coverage} returns a tibble
#' @export
#'
#' @examples
triad_coverage <- function(triads, weighted = TRUE) {
  tabTriads <- get_config(env = "spotify")$playlists %>%
    purrr::transpose() %>%
    tibble::as_tibble() %>%
    tidyr::unnest(cols = c(triad, name, playlist))
  
  if(weighted) {
    attempt::stop_if_not(rlang::has_name(triads, name = "weighted_year_country"),
                         msg = "triads must have a column weighted_year_country")
  } else {
    triads <- triads %>% 
      dplyr::mutate(weighted_year_country = 1L)
  }
  
  dat <- triads %>%
    ## Count Number of Song per Triad
    dplyr::group_by(triad) %>%
    dplyr::summarise(
      Nb_Songs = length(unique(paste(ISRC, Song))),
      Weighted_Nb_Songs = sum(weighted_year_country, na.rm = TRUE),
      .groups = "drop"
    ) %>%
    ## Join with triad names
    dplyr::full_join(dplyr::select(tabTriads, triad, name),
                     by = dplyr::join_by(triad)) %>%
    # Filter out non-triad
    dplyr::filter(grepl(pattern = "^-?[0-9]+ -?[0-9]+$", x = triad)) %>%
    ## Extract Intervals
    dplyr::mutate(triad_tmp = triad) %>%
    tidyr::extract(col = triad_tmp, into = c("First_Interval", "Second_Interval"), regex = "^(.*) (.*)$") %>%
    dplyr::mutate(dplyr::across(.cols = c(First_Interval, Second_Interval), .fns = as.integer)) %>%
    ## Filter Out Negative Triad etc.
    dplyr::filter(dplyr::between(First_Interval, -2L, 2L)) %>%
    # dplyr::filter(dplyr::between(First_Interval, 0L, 2L),
    #               dplyr::between(Second_Interval, 3L, 11L)) %>%
    dplyr::mutate(dplyr::across(.cols = c(First_Interval, Second_Interval), .fns = as.factor)) %>%
    ## Fill empty triad --> Nb songs set to zero
    # dplyr::mutate(dplyr::across(.cols = c(Nb_Songs, Weighted_Nb_Songs),
    #                             .fns = ~ dplyr::if_else(is.na(.), 0, .))) %>% 
    ## Fix triad names
    dplyr::mutate(name = gsub(" \\(.*\\)$", "", name))
  return(dat)
}
```

```{r examples-triad_coverage}
triads <- read_sheet_triad()
dat <- triad_coverage(triads = triads)
```

```{r tests-triad_coverage}
test_that("triad_coverage works", {
  expect_true(inherits(triad_coverage, "function"))
})
```

# plot_triad_coverage
    
```{r development-plot_triad_coverage}
# You can prepare the code of the plot_triad_coverage() function here
```
  
```{r function-plot_triad_coverage}
#' Plot Triad Coverage
#'
#' @param triads a tibble triad
#' @param weighted a boolean specifying if songs should be weighted using tvc's bias correction method
#'
#' @return \code{plot_triad_coverage} plots a triad coverage heatmap
#' 
#' @export
plot_triad_coverage <- function(triads, weighted = TRUE){
  dat <- triad_coverage(triads = triads, weighted = weighted) 
  dat %>%
    ggplot2::ggplot() +
    ggplot2::aes(x = First_Interval, y = Second_Interval,
                 fill = Weighted_Nb_Songs,
                 colour = triad %in% c("1 7", "-1 8", "-1 -7")) +
    ggplot2::geom_raster() +
    ggplot2::geom_text(ggplot2::aes(label = sub("Triade ", "Triade\n", name)),
                       colour = dplyr::if_else(dat$Weighted_Nb_Songs < 160L, "black", "white")) +
    # ggplot2::scale_x_discrete(limits = as.character(1:2)) +
    # ggplot2::scale_y_continuous(breaks = 5:10) +
    ggplot2::labs(x = "First Interval",
                  y = "Second Interval",
                  fill = "Number of\nSongs") +
    ggplot2::theme_bw() +
    scale_fill_tvc_c(na.value = "white")
}
```
  
```{r example-plot_triad_coverage}
triads <- read_sheet_triad()
plot_triad_coverage(triads = triads)
```
  
```{r tests-plot_triad_coverage}
test_that("plot_triad_coverage works", {
  expect_true(inherits(plot_triad_coverage, "function")) 
})
```

```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly
fusen::inflate(flat_file = "dev/flat_triad_coverage.Rmd", vignette_name = "Triad Coverage")
```

