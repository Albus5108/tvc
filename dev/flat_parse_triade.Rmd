---
title: "flat_parse_triade.Rmd empty"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)
```

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```

# clean_song_title
    
```{r development-clean_song_title}
# You can prepare the code of the clean_song_title() function here
```
  
```{r function-clean_song_title}
#' Clean Song Names
#' 
#' Remove "Remaster version" and "featuring..." mentions.
#' 
#' @param .data a data frame with two columns Song and Artist
#'
#' @return \code{clean_song_title} returns a tibble with a modified column Song
#' 
#' @export
clean_song_title <- function(.data){
  .data <- .data %>% 
    ## Nettoyer les noms de chansons
    dplyr::mutate(Song = gsub(" - .*Remaster.*$", "", Song),
                  Song = gsub("\\(feat.*\\)$", "", Song),
                  Song = gsub("\\(from.*\\)$", "", Song),
                  Song = gsub("Concerto for Trumpet and Orchestra in A-Flat Major",
                              "Concerto for Trumpet (Arutiunian)",
                              Song,
                              fixed = TRUE),
                  Song = gsub(" (with Chaka Khan)", "", Song, fixed = TRUE),
                  Song = gsub(" - From  Over The Top  Soundtrack", "", Song, fixed = TRUE),
                  Song = gsub("Bach, JS: Orchestral Suite No. 2 in B Minor, BWV 1067: VII. ", "", Song, fixed = TRUE),
                  Song = gsub("(British National Anthem 1952-2022)", "", Song, fixed = TRUE),
                  Song = gsub("/Soundtrack Version", "", Song, fixed = TRUE),
                  Song = gsub("- Jeremy Wheatley Mix", "", Song, fixed = TRUE),
                  Song = gsub("- Unedited Single Version; 2006 Remaster", "", Song, fixed = TRUE),
                  Song = gsub(", BWV 565: I. Toccata", "", Song, fixed = TRUE),
                  Song = gsub("(2024 Remaster)", "", Song, fixed = TRUE),
                  Song = dplyr::if_else(Artist == "Le Youth" & Song == "Underwater",
                                        paste(Song, "(LY)"), Song),
                  Song = gsub(" \\)", "\\)", Song))
  return(.data)
}
```
  
```{r example-clean_song_title}
tibble::tibble(Song = c("You're So Sweet Darling, BWV 565: I. Toccata",
                        "That's All Right - Remaster 2006 definitive edition"),
               Artist = c("Belzebuth & The Jeremies", "Benny Goodman")) %>% 
  clean_song_title()
```
  
```{r tests-clean_song_title}
test_that("clean_song_title works", {
  expect_true(inherits(clean_song_title, "function")) 
})
```

# parse_triade

```{r development-parse_triade}
# Prepare the code of your function here
```

```{r function-parse_triade}
#' parse_triade Title
#'
#' @param data a tibble of triads as read from googlesheet
#' @param songs a tibble of songs
#'
#' @return \code{parse_triade} returns a tibble of triads
#' @export
#' @importFrom dplyr mutate left_join join_by if_else rename case_when select case_match distinct filter
#' @importFrom tidyr unnest
#'
#' @examples
parse_triade <- function(data, songs) {
  
  if(rlang::has_name(x = songs, name = "triad")) {
    songs <- songs %>% 
      ## AVoid duplicated songs
      dplyr::select(-c(triad, name, playlist)) %>% 
      dplyr::distinct(Song, Artist, ISRC, .keep_all = TRUE)
  }
  
  data2 <- data %>%
    ## Unnest artists
    dplyr::mutate(Artist = strsplit(x = Artist, split = ",\\s?")) %>% 
    tidyr::unnest(cols = Artist) %>% 
    ## Join with songs info from Spotify
    dplyr::left_join(songs, by = dplyr::join_by(Song, Artist, ISRC)) %>%
    ## Nettoyer les noms de chansons
    clean_song_title() %>%
    ## Affirmation
    dplyr::mutate(Affirmation = dplyr::if_else(is.na(Affirmation), "Discr\u00e8te", Affirmation),
                  Affirmation = factor(x = Affirmation,
                                       levels = c(NA, "Discutable", "Discr\u00e8te", "Affirm\u00e9e", "Glorieuse", "Matraqu\u00e9e"))) %>% 
    ## Reexprimer les Degres des gammes mineures
    dplyr::rename(Degree = "Degr\u00e9 de la note m\u00e9diane") %>% 
    dplyr::mutate(Tmp = dplyr::case_when(grepl("Mineur", Mode) & Degree == "I" ~ "VI",
                                         grepl("Mineur", Mode) & Degree == "VI" ~ "IV",
                                         grepl("Mineur", Mode) & Degree == "III" ~ "I",
                                         grepl("Mineur", Mode) & Degree == "V" ~ "III",
                                         TRUE ~ Degree),
                  Degree = Tmp) %>%
    dplyr::mutate(Degree = factor(x = Degree,
                                  levels = c(NA, "I", "II", "bIII", "III", "IV", "V", "VI", "bVII", "VII"))) %>%
    dplyr::select(-Tmp) %>%
    ## Rassembler les harmonies similaires
    dplyr::mutate(Tmp_Majeur = dplyr::case_match(`Harmonie Sous-Jacente`,
                                                 c("I", "IMaj7", "VIm", "IIIm", "IIIm7") ~ "I/IIIm/VIm",
                                                 c("III", "III7(#5)", "III7(#9)") ~ "III7",
                                                 c("V", "Vsus4 ?", "Vsus4", "V7", "IV/V", "V/VII", "V/IV") ~ "V/VII, etc.",
                                                 c("IV", "IV --> V", "IV -> I", "IIm", "IImMaj7") ~ "IV/IIm",
                                                 .default = `Harmonie Sous-Jacente`),
                  Tmp_Mineur = dplyr::case_match(`Harmonie Sous-Jacente`,
                                                 c("Im", "III", "Vm") ~ "I/IIIm/VIm",
                                                 c("V") ~ "III7",
                                                 c("VII") ~ "V/VII, etc.",
                                                 c("VI", "IVm") ~ "IV/IIm",
                                                 .default = `Harmonie Sous-Jacente`),
                  `Harmonie Sous-Jacente` = dplyr::if_else(grepl("Mineur", Mode),
                                                           Tmp_Mineur,
                                                           Tmp_Majeur)) %>%
    dplyr::select(-c(Tmp_Majeur, Tmp_Mineur)) %>%
    dplyr::distinct() #%>%
    # dplyr::filter(!is.na(Degree),
    #               triad == "1 7")
  
  data2$`Harmonie Sous-Jacente` %>% unique()

  data2$Degree %>% unique()
  
  data2 %>%
    dplyr::filter(grepl("Mineur", Mode)) %>%
    dplyr::select(Song, Mode, Key, Degree)
  return(data2)
}
```

```{r examples-parse_triade}
triads <- read_sheet_triad()
playlist_id <- get_playlist_id(triad = "1 7")
songs <- tvc:::get_spotify_api_playlist(playlist_id = playlist_id, scope = "public")
data <- parse_triade(triads, songs)
```

```{r tests-parse_triade}
test_that("parse_triade works", {
  expect_true(inherits(parse_triade, "function"))
})
```


```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly
fusen::inflate(flat_file = "dev/flat_parse_triade.Rmd", vignette_name = "parse_triade")
```

