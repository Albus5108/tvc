---
title: "flat_get_spotify_api_playlist.Rmd empty"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)
library(tvc)
library(spotifyr)
```

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```

# auth_spotify

```{r development-auth_spotify}
# Prepare the code of your function here
```

```{r function-auth_spotify}
#' Authentifie l’accès Spotify
#' @param client_id Optionnel (sinon lu depuis SPOTIFY_CLIENT_ID)
#' @param client_secret Optionnel (sinon lu depuis SPOTIFY_CLIENT_SECRET)
#' @return \code{auth_spotify} returns a token (invisible) used by spotifyr
#' @importFrom spotifyr get_spotify_access_token
auth_spotify <- function(client_id = NULL,
                         client_secret = NULL, scope = c("public")) {
  if(is.null(client_id)) {
    keysAPI <- get_config(env = "spotify")
  } else {
    keysAPI <- list("client_id" = client_id,
                    "client_secret" = client_secret)
  }
  
  stopifnot(nzchar(keysAPI$client_id), nzchar(keysAPI$client_secret))
  
  if(!("private" %in% scope)) {
    ## public playlists only
    token <- spotifyr::get_spotify_access_token(client_id = keysAPI$client_id,
                                                client_secret = keysAPI$client_secret)
  } else {
    ## we need the scope playlist-read-private
    ## Spotify interdit l'url utilise par spotifyr
    tvc_get_spotify_authorization_code <- function (client_id = Sys.getenv("SPOTIFY_CLIENT_ID"),
                                                    client_secret = Sys.getenv("SPOTIFY_CLIENT_SECRET"),
                                                    scope = spotifyr::scopes()) {
      endpoint <- httr::oauth_endpoint(authorize = "https://accounts.spotify.com/authorize", 
                                       access = "https://accounts.spotify.com/api/token")
      app <- httr::oauth_app(appname = "get-tvc",
                             key = client_id,
                             secret = client_secret,
                             redirect_uri = "http://127.0.0.1:1410/")
      # app <- httr::oauth_app(appname = "spotifyr",
      #                        key = client_id,
      #                        secret = client_secret,
      #                        redirect_uri = "http://127.0.0.1:1410/")
      token <- (purrr::safely(.f = httr::oauth2.0_token))(endpoint = endpoint, 
                                                          app = app, scope = scope)
      if (!is.null(token$error)) {
        token$error
      }
      else {
        token$result
      }
    }
  
    token <- tvc_get_spotify_authorization_code(
      client_id = keysAPI$client_id,
      client_secret = keysAPI$client_secret,
      scope = "playlist-read-private"
      )
    token <- token$credentials$access_token
  }
  invisible(token)
}
```

```{r examples-auth_spotify}
token <- tvc:::auth_spotify()
```

```{r tests-auth_spotify}
test_that("auth_spotify works", {
  expect_true(inherits(auth_spotify, "function"))
  expect_no_error(token <- auth_spotify())
  expect_true(is.character(token))
  expect_gt(nchar(token), expected = 100L)
})
```

# GET Spotify Playlist

```{r development-get_spotify_api_playlist}
# Prepare the code of your function here
limit = 20
offset = 0
authorization = token
params <- list(limit = limit, offset = offset)
base_url <- "https://api.spotify.com/v1/playlists/"
playlist_id <- get_playlist_id(triad = "1 7")
```

```{r function-get_spotify_api_playlist}
#' Get Tracks from Playlist Spotify
#'
#' @param env default to "spotify"
#' @param playlist_id a character vector specifying one or more playlist id
#' @param market an additional parameter passed to the Spotify API
#' @param fields an additional parameter passed to the Spotify API
#' @param scope either "public" or "private".
#' @param verbose print message in console
#'
#' @return \code{get_spotify_api_playlist} returns a tibble with spotify data. 1 row per song and a featured artist.
#' @export
#' @importFrom attempt stop_if
#' @importFrom dplyr bind_rows distinct mutate n relocate select contains rename_all left_join rename filter
#' @importFrom purrr map compact
#' @importFrom spotifyr get_playlist get_artists
#' @importFrom tibble as_tibble
#' @importFrom tidyr unnest
get_spotify_api_playlist <- function(env = "spotify", playlist_id = NULL,
                                     market = NULL, fields = NULL, scope = c("public", "private"),
                                     verbose = TRUE) {
  init_playlist_id <- playlist_id
  keysAPI <- get_config(env = "spotify")
  stopifnot(nzchar(keysAPI$client_id), nzchar(keysAPI$client_secret))
  # token <- spotifyr::get_spotify_access_token(client_id = keysAPI$client_id, client_secret = keysAPI$client_secret)
  token <- auth_spotify(client_id = keysAPI$client_id, client_secret = keysAPI$client_secret, scope = scope)
  
  playlist <- tibble::tibble(playlist_id = playlist_id) %>% 
    dplyr::mutate(
      data = purrr::map(
        .x = playlist_id,
        .f = ~ spotifyr::get_playlist(playlist_id = .x,
                                      authorization = token)
      )
    ) %>% 
    dplyr::mutate(items = purrr::map(.x = data, .f = ~ .x$tracks$items)) %>% 
    dplyr::select(-data) %>% 
    tidyr::unnest(cols = items)
                        
  ## Get Genre via artist details
  artists <- playlist$track.artists %>% 
    dplyr::bind_rows() %>% 
    tibble::as_tibble() %>% 
    dplyr::distinct()
  
  stepArtist <- 50L
  artists <- seq(0L, nrow(artists), stepArtist) %>% 
    purrr::map(.f = ~ 1L:stepArtist + .x) %>% 
    purrr::map(.f = ~ .x[.x <= nrow(artists)]) %>% 
    purrr::compact() %>% 
    purrr::map(.f = ~ spotifyr::get_artists(ids = artists$id[.x],
                                            authorization = token)) %>% 
    dplyr::bind_rows() %>% 
    tibble::as_tibble()
  
  ## Parsing
  songs <- playlist %>%
    tibble::as_tibble() %>% 
    ## Playlist Track Order
    dplyr::mutate(Playlist_Order = 1L:dplyr::n()) %>% 
    dplyr::relocate(Playlist_Order) %>% 
    ## Remove useless columns
    dplyr::select(-c(is_local, primary_color,
                     track.preview_url, track.type, track.episode, track.track,
                     track.album.type, track.album.album_type, track.album.id, track.album.artists,
                     dplyr::contains("href"), dplyr::contains("uri"), dplyr::contains("urls"),
                     dplyr::contains("available_markets"),
                     dplyr::contains("is_local"), dplyr::contains("image"),
                     dplyr::contains("added_by"))) %>% 
    dplyr::mutate(track.artists = purrr::map(track.artists, ~ dplyr::rename_all(.x, .funs = ~paste0("artist_", .)))) %>% 
    tidyr::unnest(cols = track.artists) %>% 
    ## Genres
    dplyr::left_join(dplyr::select(artists, id, genres),
                     by = c("artist_id" = "id")) %>% 
    dplyr::rename(ISRC = track.external_ids.isrc,
                  Song = track.name,
                  Artist = artist_name) %>% 
    dplyr::select(-c(dplyr::contains("artist_"))) %>% 
    dplyr::relocate(Song, Artist, ISRC) %>%
    ## Key
    dplyr::mutate(Key = as.character(NA)) %>% 
    ## Compute Album Year
    dplyr::rename(Album_Date = track.album.release_date) %>% 
    dplyr::mutate(Album_Year = as.numeric(substr(Album_Date, 1, 4))) %>% 
    dplyr::arrange(factor(playlist_id, levels = init_playlist_id)) %>% 
    tidyr::nest(data = -c(playlist_id)) %>% 
    dplyr::pull(data)
  if(length(songs) == 1L) {
    songs <- songs[[1L]] # drop
    attempt::stop_if(nrow(dplyr::filter(songs, is.na(Album_Year))) > 0L,
                   msg = "Error parsing album year.") 
  } else {
    names(songs) <- init_playlist_id
  }
  return(songs)
}

```

```{r examples-get_spotify_api_playlist}
playlist_id <- get_playlist_id(triad = "1 7")
songs <- tvc:::get_spotify_api_playlist(
  playlist_id = playlist_id,
  scope = "public"
)
```

```{r tests-get_spotify_api_playlist}
test_that("get_spotify_api_playlist works", {
  expect_true(inherits(get_spotify_api_playlist, "function"))
  playlist_id <- get_playlist_id(triad = "1 7")
  expect_no_error(songs <- get_spotify_api_playlist(playlist_id = playlist_id, scope = "public"))
  expect_true(inherits(songs, "tbl"))
  expect_gt(nrow(songs), expected = 10L)
})
```

# get_spotify_api_triad_playlists
    
```{r development-get_spotify_api_triad_playlists}
# You can prepare the code of the get_spotify_api_triad_playlists() function here
```
  
```{r function-get_spotify_api_triad_playlists}
#' Get All Triads
#' 
#' A Wrapper around \code{\link{get_spotify_api_playlist}} to get all triad's songs at once in an optimized way
#' 
#' @return \code{get_spotify_api_triad_playlists} returns a tibble of songs for different triads
#' 
#' @export
get_spotify_api_triad_playlists <- function(){
  ## Exemple Reading private playlist
  # songsNegTVC <- tvc:::get_spotify_api_playlist(playlist_id = "1wAEEcvkLBETRvIs06BK1E", scope = "private")
  tabTriads <- build_triad_from_config(env = "spotify")
  
  songs <- tabTriads %>%
    # Filter out non-triad
    dplyr::filter(grepl(pattern = "^-?[0-9]+ -?[0-9]+$", x = triad)) %>%
    dplyr::mutate(songs = get_spotify_api_playlist(playlist_id = playlist, scope = "private"))
  
  songs <- songs %>%
    tidyr::unnest(cols = songs)
  
  return(songs)
}
```
  
```{r example-get_spotify_api_triad_playlists}
# get_spotify_api_triad_playlists()
```
  
```{r tests-get_spotify_api_triad_playlists}
test_that("get_spotify_api_triad_playlists works", {
  expect_true(inherits(get_spotify_api_triad_playlists, "function")) 
})
```

```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly
fusen::inflate(flat_file = "dev/flat_get_spotify_api_playlist.Rmd", vignette_name = "Get from spotify", check = FALSE)
```

