---
title: "Bias Correction"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Bias Correction}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r}
library(tvc)
```

<!-- WARNING - This vignette is generated by {fusen} from dev/flat_bias_correction_triad.Rmd: do not edit by hand -->




# compute_interval_probability
    
  
  
```{r example-compute_interval_probability}
stat_interval <- compute_interval_probability()
```

  

# compute_triad_probability_old
    
  
  
```{r example-compute_triad_probability_old}
stat_interval <- compute_interval_probability(nb_interval = 3)
interval_occurence <- compute_triad_probability_old(stat_interval)
```

  

# compute_triad_probability
    
  
  
```{r example-compute_triad_probability}
interval_occurence <- compute_triad_probability(nb_interval = 500L, nb_min = 1L, prob_alien = .5)
```

  

# mutate_triad_occurence_per_song
    
  
  
```{r example-mutate_triad_occurence_per_song}
stat_interval <- compute_interval_probability(nb_interval = 3)
interval_occurence <- compute_triad_probability(stat_interval)
songs <- tibble::tibble(
  ISRC = sample(LETTERS, size = 15L),
  triad = sample(x = unique(interval_occurence[["triad"]]),
                 size = 15L, replace = TRUE)
)
triad_occurence <- mutate_triad_occurence_per_song(
  interval_occurence = interval_occurence,
  songs = songs,
  nb_fake_song = 5L
)
```

  

# compute_triad_weight
    
  
  
```{r example-compute_triad_weight}
stat_interval <- compute_interval_probability(nb_interval = 3)
interval_occurence <- compute_triad_probability(stat_interval)
songs <- tibble::tibble(
  ISRC = sample(LETTERS, size = 15L),
  triad = sample(x = unique(interval_occurence[["triad"]]),
                 size = 15L, replace = TRUE)
)
triad_occurence <- mutate_triad_occurence_per_song(
  interval_occurence = interval_occurence,
  songs = songs,
  nb_fake_song = 5L
)
w_triad <- compute_triad_weight(
  songs = songs,
  triad_occurence = triad_occurence
)
```

  

# apply_triad_weight
    
  
  
```{r example-apply_triad_weight}
# time_space_triad0 <- apply_triad_weight(
#   songs = songs,
#   w_triad = w_triad,
#   regions = regions
# )
```

  

# compute_time_space_weight
    
  
  
```{r example-compute_time_space_weight}
compute_time_space_weight()
```

  
  
# apply_time_space_weight
    
  
  
```{r example-apply_time_space_weight}
apply_time_space_weight()
```

  
  

# bias_correction_triad

Over 100 millions songs exist and approximately 100,000 are released every single day. Given our cultural background, we are more familiar with western music from the 60's up until year 2010.
As a consequence, we are well aware that our dataset is heavily biased in both Time & Space. Furthermore, as we started with a single playlist to log "Vanessa Carlton" triad songs, putting all our efforts into it for a year or so, the dataset is not likely to be balanced from a triad to another. For all these reasons, we implemented the following bias correction approach.
Unfortunately, we did not have the patience to keep up a control sample playlist of songs that we listened to and didn't contain any triad in them. 

**Triad bias**

The first issue we need to address is the balance between triads. We need to assume for a moment that the occurence of a triad in a piece of music is the combined probability of occurence of the first and second interval. Let's pretend that the Vanessa Carlton is not a LOT more in used than other similar triads. The occurence of the intervals between two notes in western music is documented.

The first assumption that we make is that the total song dataset is representative of all songs in Time and Space

**Time Bias**

**Space Bias**


```{r examples-bias_correction_triad}
w_time_space2 <- bias_correction_triad(songs, regions, group_year = 1L)
```




