# WARNING - Generated by {fusen} from dev/flat_get_spotify_api_playlist.Rmd: do not edit by hand # nolint: line_length_linter.

#' Get Tracks from Playlist Spotify
#'
#' @param env default to "spotify"
#' @param playlist_id a playlist id
#' @param market an additional parameter passed to the Spotify API
#' @param fields an additional parameter passed to the Spotify API
#' @param scope either "public" or "private".
#' @param verbose print message in console
#'
#' @return \code{get_spotify_api_playlist} returns a tibble with spotify data. 1 row per song and a featured artist.
#' @export
#' @importFrom attempt stop_if
#' @importFrom dplyr bind_rows distinct mutate n relocate select contains rename_all left_join rename filter
#' @importFrom purrr map compact
#' @importFrom spotifyr get_playlist get_artists
#' @importFrom tibble as_tibble
#' @importFrom tidyr unnest
#' @examples
#' playlist_id <- get_playlist_id(triad = "1 7")
#' songs <- tvc:::get_spotify_api_playlist(
#'   playlist_id = playlist_id,
#'   scope = "public"
#' )
get_spotify_api_playlist <- function(env = "spotify", playlist_id = NULL,
                                     market = NULL, fields = NULL, scope = c("public", "private"),
                                     verbose = TRUE) {
  keysAPI <- get_config(env = "spotify")
  stopifnot(nzchar(keysAPI$client_id), nzchar(keysAPI$client_secret))
  # token <- spotifyr::get_spotify_access_token(client_id = keysAPI$client_id, client_secret = keysAPI$client_secret)
  token <- auth_spotify(client_id = keysAPI$client_id, client_secret = keysAPI$client_secret, scope = scope)
  
  playlist <- spotifyr::get_playlist(playlist_id = playlist_id, authorization = token)
  
  ## Get Genre via artist details
  artists <- playlist$tracks$items$track.artists %>% 
    dplyr::bind_rows() %>% 
    tibble::as_tibble() %>% 
    dplyr::distinct()
  
  stepArtist <- 50L
  artists <- seq(0L, nrow(artists), stepArtist) %>% 
    purrr::map(.f = ~ 1L:stepArtist + .x) %>% 
    purrr::map(.f = ~ .x[.x <= nrow(artists)]) %>% 
    purrr::compact() %>% 
    purrr::map(.f = ~ spotifyr::get_artists(ids = artists$id[.x],
                                            authorization = token)) %>% 
    dplyr::bind_rows() %>% 
    tibble::as_tibble()
  
  ## Parsing
  songs <- playlist$tracks$items %>%
    tibble::as_tibble() %>% 
    ## Playlist Track Order
    dplyr::mutate(Playlist_Order = 1L:dplyr::n()) %>% 
    dplyr::relocate(Playlist_Order) %>% 
    ## Remove useless columns
    dplyr::select(-c(is_local, primary_color,
                     track.preview_url, track.type, track.episode, track.track,
                     track.album.type, track.album.album_type, track.album.id, track.album.artists,
                     dplyr::contains("href"), dplyr::contains("uri"), dplyr::contains("urls"),
                     dplyr::contains("available_markets"),
                     dplyr::contains("is_local"), dplyr::contains("image"),
                     dplyr::contains("added_by"))) %>% 
    dplyr::mutate(track.artists = purrr::map(track.artists, ~ dplyr::rename_all(.x, .funs = ~paste0("artist_", .)))) %>% 
    tidyr::unnest(cols = track.artists) %>% 
    ## Genres
    dplyr::left_join(dplyr::select(artists, id, genres),
                     by = c("artist_id" = "id")) %>% 
    dplyr::rename(ISRC = track.external_ids.isrc,
                  Song = track.name,
                  Artist = artist_name) %>% 
    dplyr::select(-c(dplyr::contains("artist_"))) %>% 
    dplyr::relocate(Song, Artist, ISRC) %>%
    ## Key
    dplyr::mutate(Key = as.character(NA)) %>% 
    ## Compute Album Year
    dplyr::rename(Album_Date = track.album.release_date) %>% 
    dplyr::mutate(Album_Year = as.numeric(substr(Album_Date, 1, 4)))
  attempt::stop_if(nrow(dplyr::filter(songs, is.na(Album_Year))) > 0L,
                   msg = "Error parsing album year.") 
  return(songs)
}

