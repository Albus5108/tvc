# WARNING - Generated by {fusen} from dev/flat_parse_triade.Rmd: do not edit by hand # nolint: line_length_linter.

#' parse_triade Title
#'
#' @param data a tibble of triads as read from googlesheet
#' @param songs a tibble of songs
#'
#' @return \code{parse_triade} returns a tibble of triads
#' @export
#' @importFrom dplyr mutate left_join join_by if_else rename case_when select case_match distinct filter
#' @importFrom tidyr unnest
#'
#' @examples
#' triads <- read_sheet_triad()
#' playlist_id <- get_playlist_id(triad = "1 7")
#' songs <- tvc:::get_spotify_api_playlist(playlist_id = playlist_id, scope = "public")
#' data <- parse_triade(triads, songs)
parse_triade <- function(data, songs) {
  
  if(rlang::has_name(x = songs, name = "triad")) {
    songs <- songs %>% 
      ## AVoid duplicated songs
      dplyr::select(-c(triad, name, playlist)) %>% 
      dplyr::distinct(Song, Artist, ISRC, .keep_all = TRUE)
  }
  
  data2 <- data %>%
    ## Unnest artists
    dplyr::mutate(Artist = strsplit(x = Artist, split = ",\\s?")) %>% 
    tidyr::unnest(cols = Artist) %>% 
    ## Join with songs info from Spotify
    dplyr::left_join(songs, by = dplyr::join_by(Song, Artist, ISRC)) %>%
    ## Nettoyer les noms de chansons
    clean_song_title() %>%
    ## Affirmation
    dplyr::mutate(Affirmation = dplyr::if_else(is.na(Affirmation), "Discr\u00e8te", Affirmation),
                  Affirmation = factor(x = Affirmation,
                                       levels = c(NA, "Discutable", "Discr\u00e8te", "Affirm\u00e9e", "Glorieuse", "Matraqu\u00e9e"))) %>% 
    ## Reexprimer les Degres des gammes mineures
    dplyr::rename(Degree = "Degr\u00e9 de la note m\u00e9diane") %>% 
    dplyr::mutate(Tmp = dplyr::case_when(grepl("Mineur", Mode) & Degree == "I" ~ "VI",
                                         grepl("Mineur", Mode) & Degree == "VI" ~ "IV",
                                         grepl("Mineur", Mode) & Degree == "III" ~ "I",
                                         grepl("Mineur", Mode) & Degree == "V" ~ "III",
                                         TRUE ~ Degree),
                  Degree = Tmp) %>%
    dplyr::mutate(Degree = factor(x = Degree,
                                  levels = c(NA, "I", "II", "bIII", "III", "IV", "V", "VI", "bVII", "VII"))) %>%
    dplyr::select(-Tmp) %>%
    ## Rassembler les harmonies similaires
    dplyr::mutate(Tmp_Majeur = dplyr::case_match(`Harmonie Sous-Jacente`,
                                                 c("I", "IMaj7", "VIm", "IIIm", "IIIm7") ~ "I/IIIm/VIm",
                                                 c("III", "III7(#5)", "III7(#9)") ~ "III7",
                                                 c("V", "Vsus4 ?", "Vsus4", "V7", "IV/V", "V/VII", "V/IV") ~ "V/VII, etc.",
                                                 c("IV", "IV --> V", "IV -> I", "IIm", "IImMaj7") ~ "IV/IIm",
                                                 .default = `Harmonie Sous-Jacente`),
                  Tmp_Mineur = dplyr::case_match(`Harmonie Sous-Jacente`,
                                                 c("Im", "III", "Vm") ~ "I/IIIm/VIm",
                                                 c("V") ~ "III7",
                                                 c("VII") ~ "V/VII, etc.",
                                                 c("VI", "IVm") ~ "IV/IIm",
                                                 .default = `Harmonie Sous-Jacente`),
                  `Harmonie Sous-Jacente` = dplyr::if_else(grepl("Mineur", Mode),
                                                           Tmp_Mineur,
                                                           Tmp_Majeur)) %>%
    dplyr::select(-c(Tmp_Majeur, Tmp_Mineur)) %>%
    dplyr::distinct() #%>%
    # dplyr::filter(!is.na(Degree),
    #               triad == "1 7")
  
  data2$`Harmonie Sous-Jacente` %>% unique()

  data2$Degree %>% unique()
  
  data2 %>%
    dplyr::filter(grepl("Mineur", Mode)) %>%
    dplyr::select(Song, Mode, Key, Degree)
  return(data2)
}
