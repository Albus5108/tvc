# WARNING - Generated by {fusen} from dev/flat_bias_correction_triad.Rmd: do not edit by hand # nolint: line_length_linter.

#' Compute Triad Weight
#' 
#' \code{compute_triad_weight} compares the triad occurrences in the songs data
#' with expected occurrences based on elementary interval probabilities.
#' @param songs a tibble of songs with at least a column `ISRC` and `triad`.
#' @param triad_occurence a tibble as returned by \code{mutate_triad_occurence_per_song}.
#'
#' @return \code{compute_triad_weight} returns a tibble with a column `weight_triad`.
#' @details If a triad is less frequent than expected, the triad weight is equal to 1. If the triad is more frequent than expected, the closer to zero is the weight.
#' 
#' @noRd
#' @examples
#' stat_interval <- compute_interval_probability(nb_interval = 3)
#' interval_occurence <- compute_triad_probability(stat_interval)
#' songs <- tibble::tibble(
#'   ISRC = sample(LETTERS, size = 15L),
#'   triad = sample(x = unique(interval_occurence[["triad"]]),
#'                  size = 15L, replace = TRUE)
#' )
#' triad_occurence <- mutate_triad_occurence_per_song(
#'   interval_occurence = interval_occurence,
#'   songs = songs,
#'   nb_fake_song = 5L
#' )
#' w_triad <- compute_triad_weight(
#'   songs = songs,
#'   triad_occurence = triad_occurence
#' )
compute_triad_weight <- function(songs, triad_occurence) {
  ## Old : moins direct et pb d'arrondi numerique
  # w_triad <- songs %>% 
  #   dplyr::group_by(triad) %>% 
  #   dplyr::summarise(Nb_Song = length(unique(ISRC))) %>%
  #   dplyr::mutate(raw_prop_triad = Nb_Song / sum(Nb_Song)) %>% 
  #   dplyr::left_join(dplyr::select(interval_occurence, triad, frequency),
  #                    by = dplyr::join_by(triad)) %>% 
  #   dplyr::mutate(
  #     frequency = frequency / sum(frequency),
  #     prop_triad = dplyr::case_when(
  #       raw_prop_triad > frequency ~ frequency,
  #       TRUE ~ raw_prop_triad),
  #     prop_triad = prop_triad /sum(prop_triad)
  #   ) %>% 
  #   dplyr::mutate(weight_triad = prop_triad / raw_prop_triad,
  #                 weight_triad = weight_triad / max(weight_triad))
  
  w_triad <- songs %>% 
    dplyr::group_by(triad) %>% 
    dplyr::summarise(Nb_Song = length(unique(ISRC))) %>%
    dplyr::mutate(raw_prop_triad = Nb_Song / sum(Nb_Song)) %>% 
    dplyr::left_join(dplyr::select(triad_occurence, triad, frequency),
                     by = dplyr::join_by(triad)) %>% 
    dplyr::mutate(
      frequency = frequency / sum(frequency),
      prop_triad = dplyr::case_when(
        raw_prop_triad > frequency ~ frequency,
        TRUE ~ raw_prop_triad),
      prop_triad = prop_triad /sum(prop_triad),
      weight_triad = 1 - (dplyr::case_when(
        raw_prop_triad - frequency > 0 ~ raw_prop_triad - frequency,
        TRUE ~ 0) / raw_prop_triad)
    )
  # identical(w_triad, w_triadNew)
  # waldo::compare(w_triad, w_triadNew)
  return(w_triad)
}
