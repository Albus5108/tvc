# WARNING - Generated by {fusen} from dev/flat_triad_coverage.Rmd: do not edit by hand # nolint: line_length_linter.

#' Triad Coverage
#'
#' @param triads a tibble triad
#' @param weighted a boolean specifying if songs should be weighted using tvc's bias correction method
#'
#' @return \code{triad_coverage} returns a tibble
#' @export
#'
#' @examples
#' triads <- read_sheet_triad()
#' dat <- triad_coverage(triads = triads)
triad_coverage <- function(triads, weighted = TRUE) {
  tabTriads <- build_triad_from_config(env = "spotify")
  
  if(weighted) {
    attempt::stop_if_not(rlang::has_name(triads, name = "weighted_year_country"),
                         msg = "triads must have a column weighted_year_country")
  } else {
    triads <- triads %>% 
      dplyr::mutate(weighted_year_country = 1L)
  }
  
  dat <- triads %>%
    ## Count Number of Song per Triad
    dplyr::group_by(triad) %>%
    dplyr::summarise(
      Nb_Songs = length(unique(paste(ISRC, Song))),
      Weighted_Nb_Songs = sum(weighted_year_country, na.rm = TRUE),
      .groups = "drop"
    ) %>%
    ## Join with triad names
    dplyr::full_join(dplyr::select(tabTriads, triad, name),
                     by = dplyr::join_by(triad)) %>%
    # Filter out non-triad
    dplyr::filter(grepl(pattern = "^-?[0-9]+ -?[0-9]+$", x = triad)) %>%
    ## Extract Intervals
    dplyr::mutate(triad_tmp = triad) %>%
    tidyr::extract(col = triad_tmp, into = c("First_Interval", "Second_Interval"), regex = "^(.*) (.*)$") %>%
    dplyr::mutate(dplyr::across(.cols = c(First_Interval, Second_Interval), .fns = as.integer)) %>%
    dplyr::mutate(dplyr::across(.cols = c(First_Interval, Second_Interval), .fns = as.factor)) %>%
    ## Fill empty triad --> Nb songs set to zero
    # dplyr::mutate(dplyr::across(.cols = c(Nb_Songs, Weighted_Nb_Songs),
    #                             .fns = ~ dplyr::if_else(is.na(.), 0, .))) %>% 
    ## Fix triad names
    dplyr::mutate(name = gsub(" \\(.*\\)$", "", name))
  return(dat)
}
